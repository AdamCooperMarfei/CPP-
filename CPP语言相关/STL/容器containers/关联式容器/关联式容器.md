##### 关联式容器

- set（集合）
- map（映射）
- multiset（多重集）
- multiset（多重映射）

关系型容器（树）序列型容器（stack queue vector deque）

跳出c++的语境，map（映射）的更常见的名字是关联数组和字典，而在json里直接被称为对象（object）

在c++外这些容器（关联数组，字典）常常是无序的；而在c++里关联容器则被认为是有序的。

名字带“multi”的允许键重复，不带的不允许键重复。set和multiset只能用来存放键，而map和multimap则存放一个个键值对。

与序列容器相比，关联容器没有前后的概念及相关的成员函数，但同样提供inset，emplace等成员函数。此外关联容器都有find，lower_bound，upper_bound等查找函数，结果是一个迭代器：

- find（k）可以找到任何一个等价于查找键k的元素(!(x<k||k<x))
- lower_bound（k）找到第一个不小于查找键k的元素(!(x<k))
- upper_bound（k）找到第一个大于查找键k的元素（k<x）

如果你需要在multimap里精确查找满足某个键的区间的话，建议使用equal_range，可以一次性取得上下界（半开半闭）

```c++
#include<tuple>
multimap<string, int>::iterator
  lower, upper;
std::tie(lower, upper) = 
  mmp.equal_range("four");
```

如果在声明关联容器时没有提供比较类型的参数，缺省使用less来进行排序。如果键的类型提供了比较算符<的重载，则不需要做任何额外的工作。否则，我们就需要对键类型进行less特化，或者提供一个其他的函数对象类型。

对于自定义类型，推荐尽量使用标准的less实现，通过重载<(及其他标准比较运算符)对该类型的对象进行排序。存储在关联容器中的键一般应该满足严格弱序关系（strict weak ordering），即：

- 对于任何该类型的对象x:!(x<x)(非自反)
- 对于任何该类型的对象x和y：如果x<y，则!(y<x)(非对称)
- 对于任何该类型的对象x，y，z:如果x<y,并且y<z，则x<z（传递性）
- 对于任何该类型的对象x，y，z：如果x和y不可比(!(x < y) 并且 !(y < x)）并且 y 和 z 不可比，则 x 和 z 不可比（不可比的传递性）

大部分情况下，类型是可以满足这些条件的，不过：

- 如果类型没有一般意义上的大小关系（如复数），我们一定要别扭地定义一个大小关系吗
- 通过比较来进行查找，插入和删除，复杂度为对数o(log(n))，有没有达到更好的性能的方法？

##### 无序关联容器

从cpp11开始，每一个关联容器都有一个对应的无序关联容器，它们是：

- unordered_set
- unordered_map
- unordered_multiset
- unordered_multimap

它们都是以哈希表实现的。

这些容器和关联容器非常相似，主要的区别就在于它们是“无序”的。这些容器不要求提供一个排序的函数对象，而要求一个可以计算哈希值的函数对象
